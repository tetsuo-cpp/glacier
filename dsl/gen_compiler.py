from dsl import ops

HEADER = "# Generated by glacierdsl - DO NOT EDIT.\n"
IMPORTS = """
from compiler import bytecode
"""
INDENT = " " * 8


# Convert names_like_this to NamesLikeThis.
def _convert_snake_to_pascal(snake_str):
    convert_str = str()
    to_upper = True
    for c in snake_str:
        if to_upper:
            convert_str += c.upper()
            to_upper = False
        elif c == "_":
            to_upper = True
        else:
            convert_str += c
    return convert_str


def _gen_op(op):
    # Generate constructor.
    ctor_source = "def __init__(self"
    for arg in op.args:
        ctor_source += ", {}".format(arg.name)
    ctor_source += "):\n"
    if op.args:
        for arg in op.args:
            ctor_source += INDENT + "self.{0} = {0}\n".format(arg.name)
    else:
        ctor_source += INDENT + "pass\n"

    # Generate serialise function.
    serialise_source = "def serialise(self, bc):\n"
    serialise_source += INDENT + "args = list()\n"
    # Now supply arguments.
    for arg in op.args:
        if isinstance(arg, ops.GlacierVMArg):
            serialise_source += INDENT + "args.append(self.{})\n".format(arg.name)
        else:
            assert isinstance(arg, ops.GlacierVMEnumeratedArg)
            serialise_source += INDENT + "args.append(len(self.{}))\n".format(arg.name)
            serialise_source += INDENT + "args.extend(self.{})\n".format(arg.name)
    # Write the actual opcode.
    serialise_source += INDENT + "bc.write_op(bytecode.OpCode.{}, args)\n".format(op.name.upper())

    # Create the class.
    op_source = """
class GlacierOp{0}:
    {1}
    {2}
""".format(
        _convert_snake_to_pascal(op.name), ctor_source, serialise_source
    )
    return op_source


def gen_compiler(op_list):
    source = HEADER + IMPORTS
    for op in op_list:
        source += _gen_op(op)
    return source
